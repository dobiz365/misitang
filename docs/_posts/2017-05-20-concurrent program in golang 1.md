---
layout: post
title: Go语言并发处理（1）
categories: golang
description:  当被问到为什么用Go语言，一定不得不提的是Go语言的并发程序编写。在java中非常繁琐复杂的并发程序在Go语言中总是显得如此便捷。简单到只要用一个关键词go就可实现，但在我们使用时，我们会发现，并发没有那到好编写，还是需要学一些东西的。
keywords: golang, 并发 ,通信
---

### Go语言并发处理（1）

当被问到为什么用Go语言，一定不得不提的是Go语言的并发程序编写。在java中非常繁琐复杂的并发程序在Go语言中总是显得如此便捷。简单到只要用一个关键词go就可实现，但在我们使用时，我们会发现，并发没有那到好编写，还是需要学一些东西的。今天米斯唐老师（[http://www.misitang.com](http://www.misitang.com)）带领大家来学第一个并发的程序。

#### 1.怎样并发
GO语言中实现并发是所有语言中最简单的，首先你得定义好你的函数，要实现这个函数的并发执行，只要用go关键字就可以了。比如用下面这个代码：

```
package main
import ("fmt")

func say() {
	fmt.Println("say()")
}

func main() {
	go say()
}

```
上面的代码已经实现了基本的并发执行，但是好像也有问题呢？我们在控制台上并没有发现有say()的输出，难道是GO语言的BUG。这就是我要讲的第二点。

#### 2.并发线程的生命周期
在GO语言中，使用go关键字通知runtime创建一个并发线程（官方称为协程，为方便大家理解，本篇用线程代替），并把参数交给runtime后立即返回。runtime则负责创建线程并执行say函数，say函数执行完毕则线程生命结束，runtime负责资源的回收。

在本程序中，由于go say()后主线程马上结束了，主线程结束时runtime会自动kill所有主线程创建的线程，所以我们总是看不到say()的输出。这里，我们就可以看到子线程的死亡有两种途径，一种是子线程运行结束，另一种是主线程运行结束runtime主动杀死子线程。

#### 3.母子线程配合方式
在上面的主线程中加一个延时，就可以确保子线程正确运行，如下所示：
```
package main
import (
	"fmt"
	"time"
)

func say() {
	fmt.Println("say()")
}

func main() {
	go say()
	time.Sleep(100)
}

```
但在实际的编程中，子线程的运行时间一般都是不可控的，谁都不知道子线程什么时候完成了。所以这种方法只能是一种演示，我们不可能用这样的方法解决问题，其实在GO语言中已经为我们提供了解决问题的方法。

#### 4.线程之间通信
我们可以用线程间的通信来解决上面的问题，简单来说就是：主线程问子线程“你的工作做好了吗？”，子线程说“我做完了！”，这时主线程就可以退出了。就这么简单。
```
package main

import (
	"fmt"
)

func say(c chan int) {

	fmt.Println("say()")
	c <- 1					//在管道里写入一个数据
}

func main() {
	c := make(chan int)		//创建一个通信管道，类型是int型，默认管道容量是1个。
	go say(c)
	<-c						//从管道里取数据，如果没有数据，则程序被阻塞
}
```
加入go语言编程进阶群，进步会更快。

##### 5.总结
GO语言的并发编程是我见过的最简单的，没有之一。使用简单的语法就可以实现并发以及并发之间的通信，虽然GO语言的各并发线程间可以共享内存，但共享内存在并发读写时很有可能造成不同步。如果只是读取，那么共享内存的解决方法也是很好的，如果还要写入，则就不可取。使用chan是最好的办法。